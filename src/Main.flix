use Char.isLetter
use FileReadWithResult.isDirectory
use Char.isDigit

type alias PResult = List[Char]

///
/// effect for the inner workings of a combined parser
/// these effects specify exactly how the parser behaves
/// while parsing
///
eff Parsing {

    /// this effect handles the execution of atomic parsers
    def satisfy(p : List[Char] -> Option[(List[Char], List[Char])]) : PResult
    
    /// this effect allows us to implement binary decision points
    def flip() : Bool
}

///
/// effect for handling the result of the parsing process
/// 
/// here we define how to handle failure but also how to 
/// combine the results from individual parsing steps
///
eff PStrategy {
    def fail() : PResult
    def join(lhs : PResult, rhs : PResult) : PResult
}

/// 
/// builds the behavior of a single character-parse from a predicate
///
/// this is a helper function to easily construct parameters for the 
/// Parsing.satisfy effect from a predicate, that only parse one symbol
///
/// Returns a function that separates the head and tail of its input list in a tuple
/// if the head satisfies the predicate
///
def sat(predicate : Char -> Bool) : List[Char] -> Option[(List[Char], List[Char])] = 
    input -> match input {
        case Nil => None
        case x::xs => if(predicate(x)) Some((x::Nil,xs)) else None
    }

///
/// constructs a parser that consumes no symbol and leaves the input untouched
///
/// returns a parser that decides L = {epsilon}
def empty() : PResult \ Parsing = 
    Parsing.satisfy(inp -> Some((Nil, inp)))

///
/// constructs a parser that parses s as a singular symbol
///
/// returns a parser that decides L = {s}
///
def symbol(s : Char) : PResult \ Parsing = 
    Parsing.satisfy(sat(c -> c == s))

///
/// constructs a parser that parses a digit 
///
/// returns a parser that that decides L = {0, 1, ..., 9}
///
def digit() : PResult \ Parsing = 
    Parsing.satisfy(sat(isDigit))

///
/// constructs a parser that parses a letter
///
/// returns a parser that that decides L = {A, B, ..., Z, a, b, ..., z}
///
def letter() : PResult \ Parsing = 
    Parsing.satisfy(sat(isLetter))

//TODO 
// def toke(str : String) : PResult \ Parsing = 

///
/// takes 2 parser left and right (both wrapped into lambdas to defer execution) 
/// and constructs from them a parser that applies left and/or right depending on the parsing strategy
///
/// if left decide L1 and right decides L2 then the resulting Parser decides L1 + L2
///
def choice(left : Unit -> PResult \ Parsing, right : Unit -> PResult \ Parsing) : PResult \ Parsing =
    let decision = Parsing.flip();
    if(decision) left() else right()

///
/// takes in a parser p (wrapped into a lambda to defer execution)
/// then builds a parser that repeatedly applies p until it fails 
///
/// (TODO atm this fails when no symbol is parsed, it should however always succed on epsilon at least)
///
/// if p decides L then the resulting Parser decides L*
///
def many(p : Unit -> PResult \ Parsing) : PResult \ Parsing = choice(_ -> many1(p), empty)

///
/// takes in a parser p (wrapped into a lambda to defer execution)
/// then builds a parser that repeatedly applies p until it fails but at least once 
/// 
/// if p decides L then the resulting parser decides L+
///
def many1(p : Unit -> PResult \ Parsing) : PResult \ Parsing = {p(); many(p)}

def runParser(input : List[Char]) : PResult \ PStrategy = 
    region exec {
        let src = Ref.fresh(exec, input);
        run{
            many(empty);
            digit()
        }with handler Parsing {
            def satisfy(p, k) = 
                match p(Ref.get(src)) {
                    case None => PStrategy.fail() 
                    case Some((v, rest)) => {Ref.put(rest, src); PStrategy.join(v, k(Nil))} 
                }
            def flip(k) = 
                let stash = Ref.get(src);
                let eager = k(true);
                if (eager != Nil) eager else {Ref.put(stash, src); k(false)} // muss hier != Nil oder kann man direkt an fail() kn√ºpfen?
        }
    }


// The main entry point.
def main(): PResult \ IO =
    let src = '1'::'b'::'a'::'a'::'a'::Nil;
    run{
        runParser(src)
    }with handler PStrategy {
        def fail(k) = k(Nil)
        def join(lhs, rhs, k) = k(lhs ::: rhs)
    }
    

    // TODO
    // deal with many(empty) situation
    // there needs to be a way to distinguish between succesfull parses on empty lists and fails 
    // put parser in a module
    // build some examples
    // do test cases
